// Code generated by protoc-gen-oracall. DO NOT EDIT!
package ORA21062_test

import (
	"context"
	"database/sql"
	"flag"
	"os"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/google/go-cmp/cmp"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/types/known/timestamppb"

	godror "github.com/godror/godror"

	"github.com/tgulacsi/oracall/protoc-gen-oracall/testdata/ORA21062"
)

var (
	_ context.Context
	_ = timestamppb.New
	_ = cmp.Diff
)

var (
	flagConnect = flag.String("connect", os.Getenv("ORACALL_DSN"), "DSN to connect with")
	db          *sql.DB
	dbOnce      sync.Once
)

func getTx(ctx context.Context, t *testing.T) (*sql.Tx, error) {
	var err error
	dbOnce.Do(func() {
		if db, err = sql.Open("godror", *flagConnect); err == nil {
			cv, _ := godror.ClientVersion(ctx, db)
			sv, _ := godror.ServerVersion(ctx, db)
			t.Logf("Client: %+v; Server: %+v", cv, sv)
		}
	})
	if err != nil {
		return nil, err
	}
	return db.BeginTx(ctx, nil)
}
func fakeData(t *testing.T, dest any, fieldType string) {
	// t.Logf("fakeData: %T (%q)", dest, fieldType)
	var typ string
	var length, precision, scale int
	if fieldType != "" {
		if typ, rest, ok := strings.Cut(strings.TrimSuffix(fieldType, ")"), "("); ok {
			if strings.Contains(typ, "CHAR") {
				length, _ = strconv.Atoi(strings.TrimSuffix(rest, ")"))
			} else if precS, scaleS, ok := strings.Cut(rest, ","); ok {
				precision, _ = strconv.Atoi(precS)
				scale, _ = strconv.Atoi(scaleS)
			} else {
				precision, _ = strconv.Atoi(rest)
			}
		}
	}
	const num38 = "1234567890" + "1234567890" + "1234567890" + "12345678"
	switch x := dest.(type) {
	case *time.Time:
		*x = time.Now().UTC().Truncate(time.Second)
		return
	case *timestamppb.Timestamp:
		*x = *(timestamppb.New(time.Now().UTC().Truncate(time.Second)))
		return
	case **timestamppb.Timestamp:
		*x = timestamppb.New(time.Now().UTC().Truncate(time.Second))
		return
	case *string:
		if length > 0 {
			*x = strings.Repeat("x", length)
		} else if precision > 0 {
			if scale > 0 {
				*x = num38[:precision-scale] + "." + num38[precision-scale:precision]
			} else {
				*x = num38[:precision]
			}
		} else {
			*x = "-16"
		}
		return
	}
	rv := reflect.ValueOf(dest)
	if rv.IsNil() {
		rv.Set(reflect.New(rv.Type().Elem()))
	}
	rv = rv.Elem()
	rt := rv.Type()
	switch rt.Kind() {
	case reflect.Pointer:
		fakeData(t, rv.Interface(), fieldType)
	case reflect.Bool:
		rv.SetBool(true)
	case reflect.Int:
		rv.SetInt(-999999999)
	case reflect.Int8:
		rv.SetInt(-118)
	case reflect.Int16:
		rv.SetInt(-32716)
	case reflect.Int32:
		rv.SetInt(-999999932)
	case reflect.Int64:
		rv.SetInt(-1234567890123456764)
	case reflect.Uint:
		rv.SetUint(999999999)
	case reflect.Uint8:
		rv.SetUint(118)
	case reflect.Uint16:
		rv.SetUint(32716)
	case reflect.Uint32:
		rv.SetUint(999999932)
	case reflect.Uint64:
		rv.SetUint(1234567890123456764)
	case reflect.Float32:
		rv.SetFloat(3.1432)
	case reflect.Float64:
		rv.SetFloat(3.1464000000000003)
	case reflect.String:
		var s string
		if strings.Contains(typ, "CHAR") {
			if length > 0 {
				s = strings.Repeat("X", length)
			}
		} else if precision > 0 {
			if scale > 0 {
				s = num38[:precision-scale] + "." + num38[precision-scale:precision]
			} else {
				s = num38[:precision]
			}
		}
		if s == "" {
			s = "X"
		}
		rv.SetString(s)

	case reflect.Slice:
		ss := reflect.MakeSlice(rt, 0, 3)
		ret := rt.Elem()
		ptr := ret.Kind() == reflect.Pointer
		if ptr {
			ret = ret.Elem()
		}
		re := reflect.New(ret)
		fakeData(t, re.Interface(), fieldType)
		if !ptr {
			re = re.Elem()
		}
		rv.Set(reflect.Append(ss, re, re))

	case reflect.Struct:
		ftr, _ := dest.(interface{ FieldTypeName(string) string })
		for i := range rt.NumField() {
			ft := rt.Field(i)
			if !ft.IsExported() {
				continue
			}
			var fieldType string
			if ftr != nil {
				fieldType = ftr.FieldTypeName(ft.Name)
			}
			var vv reflect.Value
			ptr := ft.Type.Kind() == reflect.Pointer
			if ptr {
				vv = reflect.New(ft.Type.Elem())
			} else {
				vv = reflect.New(ft.Type)
			}
			fakeData(t, vv.Interface(), fieldType)
			if ptr {
				rv.FieldByIndex(ft.Index).Set(vv)
			} else {
				rv.FieldByIndex(ft.Index).Set(vv.Elem())
			}
		}
	}
}
func TestToFromObject_BrunoOwner_BzsXlsx_FontRt(t *testing.T) {
	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()
	tx, err := getTx(ctx, t)
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()
	var want, got ORA21062.BrunoOwner_BzsXlsx_FontRt
	fakeData(t, &want, "")
	wantJ, err := protojson.Marshal(&want)
	if err != nil {
		t.Fatalf("protojson.Marshal(BrunoOwner_BzsXlsx_FontRt): %+v", err)
	}
	obj, err := want.ToObject(ctx, tx)
	if err != nil {
		t.Fatalf("BrunoOwner_BzsXlsx_FontRt=%s.ToObject: %+v", wantJ, err)
	}
	if err = got.FromObject(obj); err != nil {
		t.Fatalf("BrunoOwner_BzsXlsx_FontRt.FromObject: %+v", err)
	}
	gotJ, err := protojson.Marshal(&got)
	if err != nil {
		t.Fatalf("protojson.Marshal(BrunoOwner_BzsXlsx_FontRt): %+v", err)
	}
	t.Logf("got=%s", gotJ)
	if d := cmp.Diff(string(wantJ), string(gotJ)); d != "" {
		t.Error(d, "want="+string(wantJ), "\n", "got="+string(gotJ))
	}
}
func TestToFromObject_BrunoOwner_BzsXlsx_RichTextRt(t *testing.T) {
	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()
	tx, err := getTx(ctx, t)
	if err != nil {
		t.Fatal(err)
	}
	defer tx.Rollback()
	var want, got ORA21062.BrunoOwner_BzsXlsx_RichTextRt
	fakeData(t, &want, "")
	wantJ, err := protojson.Marshal(&want)
	if err != nil {
		t.Fatalf("protojson.Marshal(BrunoOwner_BzsXlsx_RichTextRt): %+v", err)
	}
	obj, err := want.ToObject(ctx, tx)
	if err != nil {
		t.Fatalf("BrunoOwner_BzsXlsx_RichTextRt=%s.ToObject: %+v", wantJ, err)
	}
	if err = got.FromObject(obj); err != nil {
		t.Fatalf("BrunoOwner_BzsXlsx_RichTextRt.FromObject: %+v", err)
	}
	gotJ, err := protojson.Marshal(&got)
	if err != nil {
		t.Fatalf("protojson.Marshal(BrunoOwner_BzsXlsx_RichTextRt): %+v", err)
	}
	t.Logf("got=%s", gotJ)
	if d := cmp.Diff(string(wantJ), string(gotJ)); d != "" {
		t.Error(d, "want="+string(wantJ), "\n", "got="+string(gotJ))
	}
}
